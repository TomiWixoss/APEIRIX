# Dynamic Lore Refactor Plan

## Goal
Lore hoàn toàn dynamic - tự động generate từ attributes, không cần YAML templates

## Current Problems
1. Lore phụ thuộc vào YAML templates (`lore: lang:lore.auto`)
2. Vanilla items (dirt, stone) không có lore vì không có template
3. DynamicAttributeStorage không work cho stackable items (dynamicProperties limitation)
4. Lore không auto-update khi attributes thay đổi

## Solution Architecture

### 1. Remove Lore Templates Dependency
- LoreSystem không cần `loreMap` từ GENERATED_WIKI_ITEMS
- Mọi item có attributes → tự động có lore
- Lore = pure function of attributes

### 2. Unified Attribute Resolution
AttributeResolver cần check 3 sources:
- Static (YAML) - `getItemAttributes(itemId)`
- Dynamic (ItemStack) - `DynamicAttributeStorage.load(itemStack)` 
- Block-type (Registry) - `GlobalBlockAttributeRegistry.getAllAttributesForBlock(itemId)`

### 3. Auto-Apply Lore
```typescript
Item enters inventory
  ↓
hasAnyAttributes(item) ?
  ↓ YES
Generate lore from attributes
  ↓
Apply lore (setLore)
```

### 4. Handle Stackable Items
**Problem:** Cannot use dynamicProperties on stackable items

**Solutions:**
- **Option A:** Use nameTag component (works for stackable)
- **Option B:** Only support non-stackable items
- **Option C:** Use lore itself as storage (encode attributes in lore)

**Recommendation:** Option C - Encode attributes in lore
- Lore line format: `§r§0{attr:requires_tool:axe}§r§eYêu cầu: §fRìu`
- Hidden prefix `§r§0{...}§r` contains attribute data
- Parse lore to extract attributes when needed

## Implementation Steps

### Step 1: Refactor AttributeResolver
Add method to check block-type attributes:
```typescript
static resolve(itemStack: ItemStack): ResolvedAttribute[] {
  // 1. Static from YAML
  // 2. Dynamic from ItemStack
  // 3. Block-type from GlobalBlockAttributeRegistry
}
```

### Step 2: Refactor LoreSystem
Remove loreMap dependency:
```typescript
static applyLore(itemStack: ItemStack): boolean {
  // Always generate from attributes
  const lore = PlaceholderRegistry.generateAttributeLore(itemStack);
  if (lore.length > 0) {
    itemStack.setLore(lore);
    return true;
  }
  return false;
}
```

### Step 3: Encode Attributes in Lore
```typescript
// Format: §r§0{attr:id:config}§r{visible text}
function encodeLoreLine(attrId: string, config: any, text: string): string {
  const encoded = JSON.stringify({ id: attrId, config });
  return `§r§0${encoded}§r${text}`;
}

function decodeLoreLine(line: string): { attrId: string; config: any; text: string } | null {
  const match = line.match(/^§r§0(.+?)§r(.+)$/);
  if (match) {
    const data = JSON.parse(match[1]);
    return { attrId: data.id, config: data.config, text: match[2] };
  }
  return null;
}
```

### Step 4: Update DynamicAttributeStorage
Fallback to lore-based storage for stackable items:
```typescript
static save(itemStack: ItemStack, data: DynamicAttributeData): void {
  try {
    // Try dynamicProperties first
    itemStack.setDynamicProperty('apeirix:attributes', JSON.stringify(data));
  } catch (error) {
    // Fallback: encode in lore (for stackable items)
    console.warn('[DynamicAttributeStorage] Using lore-based storage');
    // Lore will be generated by LoreSystem
  }
}
```

### Step 5: Auto-Apply on Inventory Change
```typescript
world.afterEvents.playerInventoryItemChange.subscribe((event) => {
  const { itemStack } = event;
  if (!itemStack) return;
  
  // Check if has any attributes
  const hasAttrs = AttributeResolver.resolve(itemStack).length > 0;
  if (hasAttrs) {
    LoreSystem.applyLore(itemStack);
    // Save back to container
    container.setItem(slot, itemStack);
  }
});
```

## Benefits
1. ✅ No YAML templates needed
2. ✅ Works for vanilla items (dirt, stone)
3. ✅ Works for stackable items
4. ✅ Lore auto-updates when attributes change
5. ✅ Attributes persist in lore (no dynamicProperties needed)

## Migration
- Existing items with `lore: lang:lore.auto` → still work (lore overwritten)
- Existing items without lore → get lore if have attributes
- No breaking changes

## Testing
1. Transfer attribute log → dirt
2. Check dirt lore appears
3. Check log lore disappears
4. Stack dirt items → lore persists
5. Transfer back → lore updates
