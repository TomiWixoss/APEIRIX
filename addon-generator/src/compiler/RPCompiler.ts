import path from 'path';
import { mkdirSync, existsSync } from 'fs';
import { LangGenerator } from '../generators/LangGenerator.js';
import { TextureGenerator } from '../generators/TextureGenerator.js';

export interface RPConfig {
  items?: any[];
  blocks?: any[];
  ores?: any[];
  armor?: any[];
  tools?: any[];
  foods?: any[];
}

/**
 * Resource Pack Compiler
 * Orchestrates generation of all RP content
 */
export class RPCompiler {
  /**
   * Compile complete Resource Pack
   */
  static async compile(config: RPConfig, outputDir: string, configDir: string = ''): Promise<void> {
    console.log('\nðŸŽ¨ Compiling Resource Pack...');
    
    const rpPath = path.join(outputDir, 'RP');
    
    // Create RP structure
    this.createStructure(rpPath);
    
    let stats = {
      textures: 0,
      attachables: 0,
      langEntries: 0
    };

    // Generate texture registries
    stats.textures = await this.generateTextureRegistries(config, rpPath);

    // Generate attachables (armor)
    if (config.armor && config.armor.length > 0) {
      stats.attachables = await this.generateAttachables(config.armor, rpPath);
    }

    // Generate lang file (pass configDir)
    stats.langEntries = await this.generateLangFile(config, rpPath, configDir);

    // Generate languages.json
    this.generateLanguagesJson(rpPath);

    console.log(`âœ“ RP compiled: ${stats.textures} textures, ${stats.attachables} attachables`);
  }

  /**
   * Create RP folder structure
   */
  private static createStructure(rpPath: string): void {
    const dirs = [
      'textures/items',
      'textures/blocks',
      'textures/models/armor',
      'attachables',
      'texts'
    ];

    for (const dir of dirs) {
      const fullPath = path.join(rpPath, dir);
      if (!existsSync(fullPath)) {
        mkdirSync(fullPath, { recursive: true });
      }
    }
  }

  /**
   * Generate texture registries using TextureGenerator
   */
  private static async generateTextureRegistries(config: RPConfig, rpPath: string): Promise<number> {
    const generator = new TextureGenerator(path.dirname(rpPath));

    // Collect all items (items + tools + armor + foods)
    const allItems = [
      ...(config.items || []),
      ...(config.tools || []),
      ...(config.armor || []),
      ...(config.foods || [])
    ];

    // Generate item textures
    if (allItems.length > 0) {
      generator.generateItemTextureJson(allItems.map(item => ({
        id: item.id,
        texturePath: `textures/items/${item.id}`
      })));
    }

    // Collect all blocks (blocks + ores + deepslate ores)
    const allBlocks = [
      ...(config.blocks || []),
      ...(config.ores || [])
    ];
    
    // Add deepslate variants for ores that have deepslateTexturePath
    if (config.ores) {
      for (const ore of config.ores) {
        if (ore.deepslateTexturePath || ore.deepslateTexture) {
          allBlocks.push({
            id: `deepslate_${ore.id}`,
            name: ore.deepslateName || `Deepslate ${ore.name}`
          });
        }
      }
    }

    // Generate block textures
    if (allBlocks.length > 0) {
      generator.generateTerrainTextureJson(allBlocks.map(block => ({
        id: block.id,
        texturePath: `textures/blocks/${block.id}`
      })));
    }

    return allItems.length + allBlocks.length;
  }

  /**
   * Generate attachables for armor (already handled by ArmorGenerator in BP)
   */
  private static async generateAttachables(armor: any[], rpPath: string): Promise<number> {
    // Attachables are already generated by ArmorGenerator in BPCompiler
    // This is just for counting
    return armor.length;
  }

  /**
   * Generate lang file using LangGenerator
   */
  private static async generateLangFile(config: RPConfig, rpPath: string, configDir: string = ''): Promise<number> {
    const generator = new LangGenerator(rpPath, configDir);
    const entries: Record<string, string> = {};

    // Collect all lang entries (resolve lang: prefix)
    if (config.items) {
      for (const item of config.items) {
        if (item.name) {
          const displayName = generator.resolveName(item.name);
          entries[`item.apeirix.${item.id}.name`] = displayName;
        }
      }
    }

    if (config.tools) {
      for (const tool of config.tools) {
        if (tool.name) {
          const displayName = generator.resolveName(tool.name);
          entries[`item.apeirix.${tool.id}.name`] = displayName;
        }
      }
    }

    if (config.armor) {
      for (const armor of config.armor) {
        if (armor.name) {
          const displayName = generator.resolveName(armor.name);
          entries[`item.apeirix.${armor.id}.name`] = displayName;
        }
      }
    }

    if (config.foods) {
      for (const food of config.foods) {
        if (food.name) {
          const displayName = generator.resolveName(food.name);
          entries[`item.apeirix.${food.id}.name`] = displayName;
        }
      }
    }

    if (config.blocks) {
      for (const block of config.blocks) {
        if (block.name) {
          const displayName = generator.resolveName(block.name);
          entries[`tile.apeirix:${block.id}.name`] = displayName;
        }
      }
    }

    if (config.ores) {
      for (const ore of config.ores) {
        if (ore.name) {
          const displayName = generator.resolveName(ore.name);
          entries[`tile.apeirix:${ore.id}.name`] = displayName;
        }
        // Add deepslate variant if exists
        if (ore.deepslateTexturePath || ore.deepslateTexture) {
          // Resolve ore.name first before creating deepslate name
          const resolvedOreName = ore.name ? generator.resolveName(ore.name) : ore.id;
          const deepslateName = ore.deepslateName || `Deepslate ${resolvedOreName}`;
          const resolvedDeepslateName = deepslateName.startsWith('lang:') 
            ? generator.resolveName(deepslateName)
            : deepslateName;
          entries[`tile.apeirix:deepslate_${ore.id}.name`] = resolvedDeepslateName;
        }
      }
    }

    // Generate lang file
    generator.generate(entries, 'RP');

    return Object.keys(entries).length;
  }

  /**
   * Generate languages.json
   */
  private static generateLanguagesJson(rpPath: string): void {
    const generator = new LangGenerator(rpPath);
    generator.generateLanguagesJson('RP');
  }
}
