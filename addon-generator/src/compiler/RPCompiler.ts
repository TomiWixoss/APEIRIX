import path from 'path';
import { mkdirSync, existsSync } from 'fs';
import { LangGenerator } from '../generators/LangGenerator.js';
import { TextureGenerator } from '../generators/TextureGenerator.js';

export interface RPConfig {
  items?: any[];
  blocks?: any[];
  armor?: any[];
  tools?: any[];
  foods?: any[];
}

/**
 * Resource Pack Compiler
 * Orchestrates generation of all RP content
 */
export class RPCompiler {
  /**
   * Compile complete Resource Pack
   */
  static async compile(config: RPConfig, outputDir: string): Promise<void> {
    console.log('\nðŸŽ¨ Compiling Resource Pack...');
    
    const rpPath = path.join(outputDir, 'RP');
    
    // Create RP structure
    this.createStructure(rpPath);
    
    let stats = {
      textures: 0,
      attachables: 0,
      langEntries: 0
    };

    // Generate texture registries
    stats.textures = await this.generateTextureRegistries(config, rpPath);

    // Generate attachables (armor)
    if (config.armor && config.armor.length > 0) {
      stats.attachables = await this.generateAttachables(config.armor, rpPath);
    }

    // Generate lang file
    stats.langEntries = await this.generateLangFile(config, rpPath);

    // Generate languages.json
    this.generateLanguagesJson(rpPath);

    console.log(`âœ“ RP compiled: ${stats.textures} textures, ${stats.attachables} attachables`);
  }

  /**
   * Create RP folder structure
   */
  private static createStructure(rpPath: string): void {
    const dirs = [
      'textures/items',
      'textures/blocks',
      'textures/models/armor',
      'attachables',
      'texts'
    ];

    for (const dir of dirs) {
      const fullPath = path.join(rpPath, dir);
      if (!existsSync(fullPath)) {
        mkdirSync(fullPath, { recursive: true });
      }
    }
  }

  /**
   * Generate texture registries using TextureGenerator
   */
  private static async generateTextureRegistries(config: RPConfig, rpPath: string): Promise<number> {
    const generator = new TextureGenerator(path.dirname(rpPath));

    // Collect all items (items + tools + armor + foods)
    const allItems = [
      ...(config.items || []),
      ...(config.tools || []),
      ...(config.armor || []),
      ...(config.foods || [])
    ];

    // Generate item textures
    if (allItems.length > 0) {
      generator.generateItemTextureJson(allItems.map(item => ({
        id: item.id,
        texturePath: `textures/items/${item.id}`
      })));
    }

    // Generate block textures
    if (config.blocks && config.blocks.length > 0) {
      generator.generateTerrainTextureJson(config.blocks.map(block => ({
        id: block.id,
        texturePath: `textures/blocks/${block.id}`
      })));
    }

    return allItems.length + (config.blocks?.length || 0);
  }

  /**
   * Generate attachables for armor (already handled by ArmorGenerator in BP)
   */
  private static async generateAttachables(armor: any[], rpPath: string): Promise<number> {
    // Attachables are already generated by ArmorGenerator in BPCompiler
    // This is just for counting
    return armor.length;
  }

  /**
   * Generate lang file using LangGenerator
   */
  private static async generateLangFile(config: RPConfig, rpPath: string): Promise<number> {
    const generator = new LangGenerator(path.dirname(rpPath));
    const entries: Record<string, string> = {};

    // Collect all lang entries (same as BP)
    if (config.items) {
      for (const item of config.items) {
        if (item.name) {
          entries[`item.apeirix.${item.id}.name`] = item.name;
        }
      }
    }

    if (config.tools) {
      for (const tool of config.tools) {
        if (tool.name) {
          entries[`item.apeirix.${tool.id}.name`] = tool.name;
        }
      }
    }

    if (config.armor) {
      for (const armor of config.armor) {
        if (armor.name) {
          entries[`item.apeirix.${armor.id}.name`] = armor.name;
        }
      }
    }

    if (config.foods) {
      for (const food of config.foods) {
        if (food.name) {
          entries[`item.apeirix.${food.id}.name`] = food.name;
        }
      }
    }

    if (config.blocks) {
      for (const block of config.blocks) {
        if (block.name) {
          entries[`tile.apeirix:${block.id}.name`] = block.name;
        }
      }
    }

    // Generate lang file
    generator.generate(entries, 'RP');

    return Object.keys(entries).length;
  }

  /**
   * Generate languages.json
   */
  private static generateLanguagesJson(rpPath: string): void {
    const generator = new LangGenerator(path.dirname(rpPath));
    generator.generateLanguagesJson('RP');
  }
}
