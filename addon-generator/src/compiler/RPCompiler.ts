import path from 'path';
import { mkdirSync, existsSync } from 'fs';
import { LangGenerator } from '../generators/LangGenerator.js';
import { TextureGenerator } from '../generators/TextureGenerator.js';
import { EntityRPGenerator } from './rp/EntityRPGenerator.js';

export interface RPConfig {
  items?: any[];
  blocks?: any[];
  ores?: any[];
  armor?: any[];
  tools?: any[];
  foods?: any[];
  entities?: any[];
  enableJsonUI?: boolean;
}

/**
 * Resource Pack Compiler
 * Orchestrates generation of all RP content
 */
export class RPCompiler {
  /**
   * Compile complete Resource Pack
   */
  static async compile(config: RPConfig, outputDir: string, configDir: string = ''): Promise<void> {
    console.log('\nðŸŽ¨ Compiling Resource Pack...');
    
    const rpPath = path.join(outputDir, 'RP');
    
    // Create RP structure
    this.createStructure(rpPath);
    
    let stats = {
      textures: 0,
      attachables: 0,
      langEntries: 0
    };

    // Generate texture registries
    stats.textures = await this.generateTextureRegistries(config, rpPath);

    // Generate attachables (armor)
    if (config.armor && config.armor.length > 0) {
      stats.attachables = await this.generateAttachables(config.armor, rpPath);
    }

    // Generate entity clients
    if (config.entities && config.entities.length > 0) {
      await EntityRPGenerator.generate(config.entities, rpPath);
    }

    // Generate lang file (pass configDir)
    stats.langEntries = await this.generateLangFile(config, rpPath, configDir);

    // Generate languages.json
    this.generateLanguagesJson(rpPath);

    // Copy UI files (if enabled)
    if (config.enableJsonUI) {
      await this.copyUIFiles(rpPath, configDir);
    }

    console.log(`âœ“ RP compiled: ${stats.textures} textures, ${stats.attachables} attachables`);
  }

  /**
   * Create RP folder structure
   */
  private static createStructure(rpPath: string): void {
    const dirs = [
      'textures/items',
      'textures/blocks',
      'textures/entity',
      'textures/models/armor',
      'attachables',
      'entity',
      'models/entity',
      'animations',
      'texts'
    ];

    for (const dir of dirs) {
      const fullPath = path.join(rpPath, dir);
      if (!existsSync(fullPath)) {
        mkdirSync(fullPath, { recursive: true });
      }
    }
  }

  /**
   * Generate texture registries using TextureGenerator
   */
  private static async generateTextureRegistries(config: RPConfig, rpPath: string): Promise<number> {
    const generator = new TextureGenerator(path.dirname(rpPath));

    // Collect all items (items + tools + armor + foods + spawn eggs)
    const allItems = [
      ...(config.items || []),
      ...(config.tools || []),
      ...(config.armor || []),
      ...(config.foods || [])
    ];

    // Add spawn egg textures for entities
    if (config.entities) {
      for (const entity of config.entities) {
        if (entity.spawnEgg) {
          allItems.push({
            id: `spawn_egg_${entity.id}`,
            name: `Spawn ${entity.name}`
          });
        }
      }
    }

    // Generate item textures
    if (allItems.length > 0) {
      generator.generateItemTextureJson(allItems.map(item => ({
        id: item.id,
        texturePath: `textures/items/${item.id}`
      })));
    }

    // Collect all blocks (blocks + ores + deepslate ores + crafting blocks)
    const allBlocks = [
      ...(config.blocks || []),
      ...(config.ores || [])
    ];
    
    // Add deepslate variants for ores that have deepslateTexturePath
    if (config.ores) {
      for (const ore of config.ores) {
        if (ore.deepslateTexturePath || ore.deepslateTexture) {
          allBlocks.push({
            id: `deepslate_${ore.id}`,
            name: ore.deepslateName || `Deepslate ${ore.name}`
          });
        }
      }
    }

    // Add separate texture entries for blocks with multi-face textures
    if (config.blocks) {
      for (const block of config.blocks) {
        if (block.textureTop) {
          allBlocks.push({
            id: `${block.id}_top`,
            name: `${block.name} Top`
          });
        }
        if (block.textureSide) {
          allBlocks.push({
            id: `${block.id}_side`,
            name: `${block.name} Side`
          });
        }
        if (block.textureFront) {
          allBlocks.push({
            id: `${block.id}_front`,
            name: `${block.name} Front`
          });
        }
      }
    }

    // Generate block textures
    if (allBlocks.length > 0) {
      generator.generateTerrainTextureJson(allBlocks.map(block => ({
        id: block.id,
        texturePath: `textures/blocks/${block.id}`
      })));
    }

    return allItems.length + allBlocks.length;
  }

  /**
   * Generate attachables for armor (already handled by ArmorGenerator in BP)
   */
  private static async generateAttachables(armor: any[], rpPath: string): Promise<number> {
    // Attachables are already generated by ArmorGenerator in BPCompiler
    // This is just for counting
    return armor.length;
  }

  /**
   * Generate lang file using LangGenerator
   */
  private static async generateLangFile(config: RPConfig, rpPath: string, configDir: string = ''): Promise<number> {
    const generator = new LangGenerator(rpPath, configDir);
    const entries: Record<string, string> = {};

    // Collect all lang entries (resolve lang: prefix)
    if (config.items) {
      for (const item of config.items) {
        if (item.name) {
          const displayName = generator.resolveName(item.name);
          entries[`item.apeirix.${item.id}.name`] = displayName;
        }
      }
    }

    if (config.tools) {
      for (const tool of config.tools) {
        if (tool.name) {
          const displayName = generator.resolveName(tool.name);
          entries[`item.apeirix.${tool.id}.name`] = displayName;
        }
      }
    }

    if (config.armor) {
      for (const armor of config.armor) {
        if (armor.name) {
          const displayName = generator.resolveName(armor.name);
          entries[`item.apeirix.${armor.id}.name`] = displayName;
        }
      }
    }

    if (config.foods) {
      for (const food of config.foods) {
        if (food.name) {
          const displayName = generator.resolveName(food.name);
          entries[`item.apeirix.${food.id}.name`] = displayName;
        }
      }
    }

    if (config.blocks) {
      for (const block of config.blocks) {
        if (block.name) {
          const displayName = generator.resolveName(block.name);
          entries[`tile.apeirix:${block.id}.name`] = displayName;
        }
      }
    }

    // Note: craftingTable blocks are just regular blocks with extra component

    if (config.ores) {
      for (const ore of config.ores) {
        if (ore.name) {
          const displayName = generator.resolveName(ore.name);
          entries[`tile.apeirix:${ore.id}.name`] = displayName;
        }
        // Add deepslate variant if exists
        if (ore.deepslateTexturePath || ore.deepslateTexture) {
          // Resolve ore.name first before creating deepslate name
          const resolvedOreName = ore.name ? generator.resolveName(ore.name) : ore.id;
          const deepslateName = ore.deepslateName || `Deepslate ${resolvedOreName}`;
          const resolvedDeepslateName = deepslateName.startsWith('lang:') 
            ? generator.resolveName(deepslateName)
            : deepslateName;
          entries[`tile.apeirix:deepslate_${ore.id}.name`] = resolvedDeepslateName;
        }
      }
    }

    // Add entity names
    if (config.entities) {
      for (const entity of config.entities) {
        if (entity.name) {
          const displayName = generator.resolveName(entity.name);
          entries[`entity.apeirix:${entity.id}.name`] = displayName;
        }
        // Add spawn egg name
        if (entity.spawnEgg) {
          const spawnEggName = entity.spawnEgg.name || `Spawn ${generator.resolveName(entity.name)}`;
          entries[`item.spawn_egg.entity.apeirix:${entity.id}.name`] = spawnEggName;
        }
      }
    }

    // Generate lang file
    generator.generate(entries, 'RP');

    return Object.keys(entries).length;
  }

  /**
   * Generate languages.json
   */
  private static generateLanguagesJson(rpPath: string): void {
    const generator = new LangGenerator(rpPath);
    generator.generateLanguagesJson('RP');
  }

  /**
   * Copy UI files and textures to RP
   */
  private static async copyUIFiles(rpPath: string, configDir: string): Promise<void> {
    const { copyFileSync, readdirSync, statSync } = await import('fs');
    
    // UI JSON files are in configs/ui/
    // UI textures are in assets/ui/ (outside configs/)
    const uiSourceDir = path.join(configDir, 'ui');
    const assetsDir = path.join(path.dirname(configDir), 'assets');
    const uiTexturesSourceDir = path.join(assetsDir, 'ui');
    
    const uiDestDir = path.join(rpPath, 'ui');
    const texturesDestDir = path.join(rpPath, 'textures');
    
    // Check if UI source directories exist
    if (!existsSync(uiSourceDir)) {
      console.log('  â“˜ No UI files found in configs/ui/, skipping UI copy');
      return;
    }
    
    console.log('  ðŸ“‹ Copying JSON UI files...');
    
    // Copy UI JSON files
    this.copyDirectoryRecursive(uiSourceDir, uiDestDir);
    
    // Copy UI textures from assets/ui/ to textures/apeirix/ui/
    if (existsSync(uiTexturesSourceDir)) {
      const uiTexturesDestDir = path.join(texturesDestDir, 'apeirix', 'ui');
      this.copyDirectoryRecursive(uiTexturesSourceDir, uiTexturesDestDir);
    }
    
    console.log('  âœ“ JSON UI files copied');
  }

  /**
   * Copy directory recursively
   */
  private static copyDirectoryRecursive(source: string, dest: string): void {
    const { copyFileSync, readdirSync, statSync } = require('fs');
    
    if (!existsSync(dest)) {
      mkdirSync(dest, { recursive: true });
    }
    
    const files = readdirSync(source);
    
    for (const file of files) {
      const sourcePath = path.join(source, file);
      const destPath = path.join(dest, file);
      
      if (statSync(sourcePath).isDirectory()) {
        this.copyDirectoryRecursive(sourcePath, destPath);
      } else {
        copyFileSync(sourcePath, destPath);
      }
    }
  }
}
