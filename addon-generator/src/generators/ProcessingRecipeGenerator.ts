import { FileManager } from '../core/FileManager.js';
import { join } from 'path';

export interface ProcessingRecipeData {
  machineType: string;
  input: string;
  output: string;
  processingTime: number;
  // OreCrusher specific
  stoneDustCount?: number;
  oreDust?: string;
  oreDustCount?: number;
  // BrassSifter/OreWasher specific
  stoneDust?: string;
  pureDust?: string;
  // OreSieve specific
  outputs?: Array<{ item: string; chance: number }>;
  // Fuel config
  fuelConfig?: {
    blockId: string;
    usesPerBlock: number;
    detectFaces: 'all' | 'bottom';
  };
}

/**
 * Generator để tạo file GeneratedProcessingRecipes.ts
 */
export class ProcessingRecipeGenerator {
  private projectRoot: string;

  constructor(projectRoot: string) {
    this.projectRoot = projectRoot;
  }

  /**
   * Generate GeneratedProcessingRecipes.ts file
   */
  generate(recipes: ProcessingRecipeData[], customPath?: string): void {
    const content = this.generateContent(recipes);
    
    const outputPath = customPath 
      ? join(this.projectRoot, customPath, 'GeneratedProcessingRecipes.ts')
      : join(this.projectRoot, 'scripts/data/GeneratedProcessingRecipes.ts');
    
    FileManager.writeText(outputPath, content);
    
    const displayPath = customPath 
      ? `${customPath}/GeneratedProcessingRecipes.ts`
      : 'scripts/data/GeneratedProcessingRecipes.ts';
    console.log(`✅ Đã tạo: ${displayPath}`);
  }

  /**
   * Generate file content
   */
  private generateContent(recipes: ProcessingRecipeData[]): string {
    // Group recipes by machine type
    const recipesByMachine: Record<string, ProcessingRecipeData[]> = {};
    const fuelConfigs: Record<string, any> = {};
    
    for (const recipe of recipes) {
      if (!recipesByMachine[recipe.machineType]) {
        recipesByMachine[recipe.machineType] = [];
      }
      recipesByMachine[recipe.machineType].push(recipe);
      
      // Store fuel config (same for all recipes of a machine)
      if (recipe.fuelConfig && !fuelConfigs[recipe.machineType]) {
        fuelConfigs[recipe.machineType] = recipe.fuelConfig;
      }
    }

    return `/**
 * AUTO-GENERATED FILE - DO NOT EDIT MANUALLY
 * Generated by addon-generator CLI
 * 
 * Để thêm/sửa/xóa processing recipes:
 * 1. Edit YAML files trong addon-generator/configs/materials/processing/
 * 2. Run: bun run dev compile configs/addon.yaml
 * 3. File này sẽ được regenerate tự động
 */

export interface ProcessingRecipe {
  inputId: string;
  outputId: string;
  processingTime: number;
}

export interface OreCrusherRecipe {
  inputId: string;
  stoneDust: string;
  stoneDustCount: number;
  oreDust?: string;
  oreDustCount?: number;
}

export interface BrassSifterRecipe {
  inputId: string;
  pureDust: string;
  stoneDust: string;
}

export interface OreWasherRecipe {
  inputId: string;
  pureDust: string;
  stoneDust: string;
}

export interface OreSieveRecipe {
  inputId: string;
  outputs: Array<{ item: string; chance: number }>;
}

export interface FuelConfig {
  blockId: string;
  usesPerBlock: number;
  detectFaces: 'all' | 'bottom';
}

/**
 * Generated processing recipes grouped by machine type
 */
export const GENERATED_PROCESSING_RECIPES: Record<string, ProcessingRecipe[]> = {
${this.generateCompressorRecipes(recipesByMachine)}
};

/**
 * Generated ore crusher recipes grouped by machine type
 */
export const GENERATED_ORE_CRUSHER_RECIPES: Record<string, OreCrusherRecipe[]> = {
${this.generateOreCrusherRecipes(recipesByMachine)}
};

/**
 * Generated brass sifter recipes
 */
export const GENERATED_BRASS_SIFTER_RECIPES: BrassSifterRecipe[] = [
${this.generateBrassSifterRecipes(recipesByMachine)}
];

/**
 * Generated ore washer recipes
 */
export const GENERATED_ORE_WASHER_RECIPES: OreWasherRecipe[] = [
${this.generateOreWasherRecipes(recipesByMachine)}
];

/**
 * Generated ore sieve recipes
 */
export const GENERATED_ORE_SIEVE_RECIPES: OreSieveRecipe[] = [
${this.generateOreSieveRecipes(recipesByMachine)}
];

/**
 * Generated fuel configs for machines
 */
export const GENERATED_FUEL_CONFIGS: Record<string, FuelConfig> = {
${this.generateFuelConfigs(fuelConfigs)}
};
`;
  }

  /**
   * Generate compressor-style recipes
   */
  private generateCompressorRecipes(recipesByMachine: Record<string, ProcessingRecipeData[]>): string {
    const lines: string[] = [];
    
    for (const [machineType, recipes] of Object.entries(recipesByMachine)) {
      // Only include compressor-style recipes (has output, no stoneDust/pureDust)
      const compressorRecipes = recipes.filter(r => !r.stoneDustCount && !r.pureDust);
      
      if (compressorRecipes.length > 0) {
        lines.push(`  "${machineType}": [`);
        
        compressorRecipes.forEach((recipe, index) => {
          const isLast = index === compressorRecipes.length - 1;
          lines.push(`    { inputId: "${recipe.input}", outputId: "${recipe.output}", processingTime: ${recipe.processingTime} }${isLast ? '' : ','}`);
        });
        
        lines.push(`  ],`);
      }
    }
    
    return lines.join('\n');
  }

  /**
   * Generate ore crusher recipes
   */
  private generateOreCrusherRecipes(recipesByMachine: Record<string, ProcessingRecipeData[]>): string {
    const lines: string[] = [];
    
    for (const [machineType, recipes] of Object.entries(recipesByMachine)) {
      // Only include ore crusher recipes (has stoneDustCount, NOT pureDust)
      const crusherRecipes = recipes.filter(r => r.stoneDustCount !== undefined && !r.pureDust);
      
      if (crusherRecipes.length > 0) {
        lines.push(`  "${machineType}": [`);
        
        crusherRecipes.forEach((recipe, index) => {
          const isLast = index === crusherRecipes.length - 1;
          const oreDustPart = recipe.oreDust 
            ? `, oreDust: "${recipe.oreDust}", oreDustCount: ${recipe.oreDustCount}` 
            : '';
          lines.push(`    { inputId: "${recipe.input}", stoneDust: "${recipe.output}", stoneDustCount: ${recipe.stoneDustCount}${oreDustPart} }${isLast ? '' : ','}`);
        });
        
        lines.push(`  ],`);
      }
    }
    
    return lines.join('\n');
  }

  /**
   * Generate brass sifter recipes (OLD - now ore_sieve)
   */
  private generateBrassSifterRecipes(recipesByMachine: Record<string, ProcessingRecipeData[]>): string {
    const lines: string[] = [];
    
    for (const [machineType, recipes] of Object.entries(recipesByMachine)) {
      // Only brass_sifter with outputs (new ore_sieve logic)
      if (machineType !== 'brass_sifter') continue;
      
      const sieveRecipes = recipes.filter(r => r.outputs !== undefined);
      if (sieveRecipes.length > 0) {
        // These are actually ore_sieve recipes, skip for brass_sifter
        continue;
      }
    }
    
    return ''; // No more brass_sifter recipes
  }

  /**
   * Generate ore washer recipes (NEW - old brass_sifter logic)
   */
  private generateOreWasherRecipes(recipesByMachine: Record<string, ProcessingRecipeData[]>): string {
    const lines: string[] = [];
    let hasRecipes = false;
    
    for (const [machineType, recipes] of Object.entries(recipesByMachine)) {
      // Only ore_washer recipes (has pureDust)
      if (machineType !== 'ore_washer') continue;
      
      const washerRecipes = recipes.filter(r => r.pureDust !== undefined);
      
      if (washerRecipes.length > 0) {
        hasRecipes = true;
        washerRecipes.forEach((recipe, index) => {
          const isLast = index === washerRecipes.length - 1;
          lines.push(`  { inputId: "${recipe.input}", pureDust: "${recipe.pureDust}", stoneDust: "${recipe.stoneDust}" }${isLast ? '' : ','}`);
        });
      }
    }
    
    return hasRecipes ? lines.join('\n') : '';
  }

  /**
   * Generate ore sieve recipes (NEW - brass_sifter with new logic)
   */
  private generateOreSieveRecipes(recipesByMachine: Record<string, ProcessingRecipeData[]>): string {
    const lines: string[] = [];
    let hasRecipes = false;
    
    for (const [machineType, recipes] of Object.entries(recipesByMachine)) {
      // Only ore_sieve with outputs array
      if (machineType !== 'ore_sieve') continue;
      
      const sieveRecipes = recipes.filter(r => r.outputs !== undefined);
      
      if (sieveRecipes.length > 0) {
        hasRecipes = true;
        sieveRecipes.forEach((recipe, index) => {
          const isLast = index === sieveRecipes.length - 1;
          const outputsStr = JSON.stringify(recipe.outputs);
          lines.push(`  { inputId: "${recipe.input}", outputs: ${outputsStr} }${isLast ? '' : ','}`);
        });
      }
    }
    
    return hasRecipes ? lines.join('\n') : '';
  }

  /**
   * Generate fuel configs
   */
  private generateFuelConfigs(fuelConfigs: Record<string, any>): string {
    const lines: string[] = [];
    const entries = Object.entries(fuelConfigs);
    
    entries.forEach(([machineType, config], index) => {
      const isLast = index === entries.length - 1;
      lines.push(`  "apeirix:${machineType}": { blockId: "${config.blockId}", usesPerBlock: ${config.usesPerBlock}, detectFaces: "${config.detectFaces}" }${isLast ? '' : ','}`);
    });
    
    return lines.join('\n');
  }
}
